<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Moving vs. Static</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
</head>
<body>
<script>

    class AABB {
        constructor(center, extents) {
            this.center = center;
            this.extents = extents;
            this.color = color(random(255), random(255), random(255))
        }

        overlaps(aabb) {
            return (Math.abs(this.center.x - aabb.center.x) * 2 < (this.extents.x + aabb.extents.x) * 2) &&
                (Math.abs(this.center.y - aabb.center.y) * 2 < (this.extents.y + aabb.extents.y) * 2);
        }

        get top() {
            return this.center.y - this.extents.y;
        }

        set top(y) {
            this.center.y = y + this.extents.y;
        }

        get bottom() {
            return this.center.y + this.extents.y;
        }

        set bottom(y) {
            this.center.y = y - this.extents.y;
        }

        get left() {
            return this.center.x - this.extents.x;
        }

        set left(x) {
            this.center.x = x + this.extents.x;
        }

        get right() {
            return this.center.x + this.extents.x;
        }

        set right(x) {
            this.center.x = x - this.extents.x;
        }


        draw() {
            fill(this.color);
            rectMode(CENTER);
            rect(this.center.x, this.center.y, this.extents.x * 2, this.extents.y * 2);
        }
    }

    class MovingRect extends AABB {
        constructor(center, extents) {
            super(center, extents);
            this.oldCenter = this.center.copy();
            this.vel = createVector(0, 0);
            this.acc = createVector(0, 0);
        }

        updateMotion() {
            this.oldCenter = this.center.copy();
            this.vel.add(this.acc);
            this.center.add(this.vel);
        }

        getOld() {
            return new AABB(this.oldCenter, this.extents);
        }

        getDisplacement() {
            return p5.Vector.sub(this.oldCenter, this.center);
        }
    }

    class CollidingRect extends MovingRect {
        constructor(center, extents) {
            super(center, extents);
            this.collisionQueue = [];
        }

        onTopCollision() {

        }

        onBottomCollision() {

        }

        onLeftCollision() {

        }

        onRightCollision() {

        }

        constrainWithinScreen() {
            if (this.top < 0) {
                this.top = 0;
                this.onTopCollision();
            }

            if (this.bottom > height) {
                this.bottom = height;
                this.onBottomCollision();
            }

            if (this.left < 0) {
                this.left = 0;
                this.onLeftCollision();
            }

            if (this.right > width) {
                this.right = width;
                this.onRightCollision();
            }
        }

        resolveCollisions() {

        }

        detectCollisions() {
        }

        update() {
            this.updateMotion();

            this.detectCollisions();
            this.resolveCollisions();

            this.constrainWithinScreen();
        }
    }

    class Player extends CollidingRect {
        constructor(center) {
            super(center, createVector(16, 16));
            this.jumping = true;
            this.speed = 4;
        }

        controls() {
            if (keyIsDown(LEFT_ARROW)) {
                this.vel.x = -this.speed;
            }

            if (keyIsDown(RIGHT_ARROW)) {
                this.vel.x = this.speed;
            }

            if (keyIsDown(UP_ARROW)) {
                if (!this.jumping) {
                    this.vel.y = -12;
                    this.jumping = true;
                }
            }

            this.acc.y = 0.5;
        }

        update() {
            this.controls();
            super.update();
        }
    }

    class Tile {
        static SIZE = 32;
        x = 0;
        y = 0;
        id = -1;

        constructor(x, y, id = -1) {
            this.x = x;
            this.y = y;
            this.id = id;
        }

        toVec() {
            return createVector(
                this.x * Tile.SIZE + Tile.SIZE / 2,
                this.y * Tile.SIZE + Tile.SIZE / 2,
            );
        }

        toAABB() {
            return new AABB(createVector(
                this.x * Tile.SIZE + Tile.SIZE / 2,
                this.y * Tile.SIZE + Tile.SIZE / 2,
            ), Tile.SIZE / 2, Tile.SIZE / 2);
        }

        static toTile(vec) {
            return new Tile(
                vec.x / this.SIZE | 0,
                vec.y / this.SIZE | 0,
            );
        }
    }

    class TileMap {
        width = 0;
        height = 0;
        array = [];

        constructor(width, height, array) {
            this.width = width;
            this.height = height;
            this.array = array;
        }

        getTileIdFromVec(vec) {
            vec = Tile.toTile(vec);
            return this.array[vec.x + vec.y * this.width];
        }

        getTileId(x, y) {
            return this.array[x + y * this.width];
        }

        draw() {
            for (let x = 0; x < this.width; x++)
                for (let y = 0; y < this.height; y++) {
                    let id = this.getTileId(x, y);
                    if (id > 0) {
                        let pos = new Tile(x, y).toVec();
                        fill(135, id * 50, 255 - id * 50);
                        rectMode(CENTER);
                        stroke(255);
                        strokeWeight(1);
                        rect(pos.x, pos.y, Tile.SIZE - 1, Tile.SIZE - 1);
                    }
                }
        }
    }

    addEventListener("keydown", (e) => {
        switch (e.keyCode) {
            case LEFT_ARROW:
            case RIGHT_ARROW:
            case 32:
                e.preventDefault();
        }
    });

    let entities;
    let tileMap;

    function draw() {
        background(200);

        tileMap.draw();
        for (let entity of entities) {
            entity.update();
            entity.draw();
        }
    }

    function setup() {
        createCanvas(640, 640);
        entities = [new Player(createVector(160, 160))];
        tileMap = new TileMap(20, 20, [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
        ]);
    }

</script>
</body>
</html>