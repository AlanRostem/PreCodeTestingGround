<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minkowski AABB collision</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
</head>
<body>
<script>
    class Hit {
        constructor(aabb) {
            this.collider = aabb;
            this.pos = createVector();
            this.delta = createVector();
            this.normal = createVector();
            this.time = 0;
        };
    }

    class Sweep {
        constructor() {
            this.hit = null;
            this.pos = createVector();
            this.time = 1;
        }
    }

    class AABB {
        center = createVector(0, 0);
        extents = createVector(0, 0);

        constructor(center, extents) {
            this.center = center;
            this.extents = extents;
        }

        getMin() {
            return p5.Vector.sub(this.center, this.extents);
        }

        getMax() {
            return p5.Vector.add(this.center, this.extents);
        }

        get min() {
            return this.getMin();
        }

        get max() {
            return this.getMax();
        }

        getSize() {
            return p5.Vector.mult(this.extents, 2);
        }

        overlaps(aabb) {
            return aabb.center.x - aabb.extents.x < this.center.x + this.extents.x &&
                aabb.center.x + aabb.extents.x > this.center.x - this.extents.x &&
                aabb.center.y - aabb.extents.y < this.center.y + this.extents.y &&
                aabb.center.y + aabb.extents.y > this.center.y - this.extents.y;
        }

        intersectSegment(pos, delta, padding) {
            const scale = createVector(1 / delta.x, 1 / delta.y);
            const sign = createVector(Math.sign(scale.x), Math.sign(scale.y));
            const nearTime = createVector(
                (this.center.x - sign.x * (this.extents.x + padding.x) - pos.x) * scale.x,
                (this.center.y - sign.y * (this.extents.y + padding.y) - pos.y) * scale.y,
            );
            const farTime = createVector(
                (this.center.x + sign.x * (this.extents.x + padding.x) - pos.x) * scale.x,
                (this.center.y + sign.y * (this.extents.y + padding.y) - pos.y) * scale.y
            );

            if (nearTime.x > farTime.y || nearTime.y > farTime.x) {
                return null;
            }

            const nearTimeComputed = nearTime.x > nearTime.y ? nearTime.x : nearTime.y;
            const farTimeComputed = farTime.x < farTime.y ? farTime.x : farTime.y;

            if (nearTimeComputed >= 1 || farTimeComputed <= 0) {
                return null;
            }

            const hit = new Hit(this);
            hit.time = clamp(nearTimeComputed, 0, 1);
            if (nearTime.x > nearTime.y) {
                hit.normal.x = -sign.x;
                hit.normal.y = 0;
            } else {
                hit.normal.x = 0;
                hit.normal.y = -sign.y;
            }

            hit.delta.x = (1.0 - hit.time) * -delta.x;
            hit.delta.y = (1.0 - hit.time) * -delta.y;
            hit.pos.x = pos.x + delta.x * hit.time;
            hit.pos.y = pos.y + delta.y * hit.time;

            return hit;
        }

        intersectAABB(aabb) {
            const delta = p5.Vector.sub(aabb.center, this.center);
            let line = p5.Vector.add(aabb.extents, this.extents);
            let abs = createVector(Math.abs(delta.x), Math.abs(delta.y));
            line.sub(abs);

            if (line.x <= 0 || line.y <= 0) return null;

            const hit = new Hit(this);

            if (line.x < line.y) {
                const sx = Math.sign(delta.x);
                hit.delta.x = line.x * sx;
                hit.normal.x = sx;
                hit.pos.x = this.center.x + (this.extents.x * sx);
                hit.pos.y = aabb.center.y;
            } else {
                const sy = Math.sign(delta.y);
                hit.delta.y = line.y * sy;
                hit.normal.y = sy;
                hit.pos.x = aabb.center.x;
                hit.pos.y = this.center.y + (this.extents.y * sy);
            }

            return hit;
        }

        sweepAABB(aabb, delta) {
            const sweep = new Sweep();
            if (delta.x === 0 && delta.y === 0) {
                sweep.pos.x = aabb.center.x;
                sweep.pos.y = aabb.center.y;
                sweep.hit = this.intersectAABB(aabb);
                sweep.time = sweep.hit ? (sweep.hit.time = 0) : 1;
                return sweep;
            }

            sweep.hit = this.intersectSegment(aabb.center, delta, aabb.extents);
            if (sweep.hit) {
                sweep.time = clamp(sweep.hit.time - Math.EPSILON, 0, 1);
                sweep.pos.x = aabb.center.x + delta.x * sweep.time;
                sweep.pos.y = aabb.center.y + delta.y * sweep.time;
                const direction = delta.clone();
                direction.normalize();
                sweep.hit.pos.x = clamp(
                    sweep.hit.pos.x + direction.x * aabb.extents.x,
                    this.center.x - this.extents.x, this.center.x + this.extents.x);
                sweep.hit.pos.y = clamp(
                    sweep.hit.pos.y + direction.y * aabb.extents.y,
                    this.center.y - this.extents.y, this.center.y + this.extents.y);
            } else {
                sweep.pos.x = aabb.center.x + delta.x;
                sweep.pos.y = aabb.center.y + delta.y;
                sweep.time = 1;
            }
            return sweep;
        }

        AABBCollision(aabb) {

        }

        draw(r, g, b) {
            stroke(0);
            fill(...arguments);
            rectMode(CENTER);
            rect(this.center.x, this.center.y, this.extents.x * 2, this.extents.y * 2);
        }

        onBottomCollision() {

        }

        onTopCollision() {

        }
    }

    class Player extends AABB {

        #vel = createVector(0, 0);
        #jumping = false;

        update() {
            this.control();
            this.move();
            this.wallCollision();
        }

        onBottomCollision() {

            this.setOnGround(true);
        }

        onTopCollision() {
            this.#vel.y = 0;
        }

        control() {
            this.#vel.y += .3;

            if (keyIsDown(65)) {
                if (keyIsDown(65) && !keyIsDown(68))
                    player.walk(-speed)
            } else if (keyIsDown(68)) {
                if (!keyIsDown(65) && keyIsDown(68))
                    player.walk(speed)
            }

            if (keyIsDown(32)) {
                player.jump();
            }
        }

        move() {
            this.center.add(this.#vel);
            this.#vel.x = 0;
        }


        wallCollision() {

            if (this.center.x + this.extents.x > width) {
                this.center.x = width - this.extents.x;
            }
            if (this.center.x - this.extents.x < 0) {
                this.center.x = this.extents.x;
            }

            if (this.center.y + this.extents.y > height) {
                this.center.y = height - this.extents.y;
                this.#vel.y = 0;
                this.#jumping = false;
            }
        }

        walk(x) {
            this.#vel.x = x;
        }

        jump() {
            if (!this.#jumping) {
                this.#vel.y = -6;
                this.#jumping = true;
            }
        }

        setOnGround(value) {
            this.#jumping = !value;
            this.#vel.y = 0;
        }

        getVel() {
            return this.#vel;
        }
    }


    let player;
    let obstacles;
    let map = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
        0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
    ];
    let speed;

    function setup() {
        createCanvas(320, 320);
        player = new Player(createVector(32, 32), createVector(16, 16));
        obstacles = [];

        for (let x = 0; x < 10; x++)
            for (let y = 0; y < 10; y++) {
                let size = 16;
                if (map[x + y * 10] > 0) obstacles.push(new AABB(
                    createVector(x * size * 2 + size, y * size * 2 + size),
                    createVector(size, size)))
            }

        speed = 2;
    }

    function draw() {
        frameRate(60);

        background(150);


        player.update();
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obstacle = obstacles[i];
            player.AABBCollision(obstacle);
            obstacle.draw(0, 255, 0);
        }
        player.draw(0, 0, 0);

        //obstacle.AABBCollision(player);
    }

    /**
     *  if (this.overlaps(aabb)) {
                let difference = p5.Vector.sub(aabb.center, this.center);
                let totalExtents = p5.Vector.add(aabb.extents, this.extents);

                totalExtents.x *= Math.sign(difference.x);
                totalExtents.y *= Math.sign(difference.y);

                let overlap = p5.Vector.sub(totalExtents, difference);


                stroke(255, 0, 0);
                line(this.center.x,
                    this.center.y,
                    this.center.x + difference.x,
                    this.center.y + difference.y);

                if (Math.abs(difference.y) > Math.abs(difference.x)) {
                    this.center.y -= overlap.y;
                    if (difference.y > 0) {
                        this.onBottomCollision();
                    } else if (difference.y < 0) {
                        this.onTopCollision();
                    }
                } else if (Math.abs(difference.y) < Math.abs(difference.x)) {
                    this.center.x -= overlap.x;
                } else {
                    this.center.sub(overlap);
                }
            }
     */
</script>
</body>
</html>