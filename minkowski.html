<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minkowski AABB collision</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
</head>
<body>
<script>
    class TileMap {
        #arr = [
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        ];

        #width = 10;
        #height = 10;
        #size = 32;

        get(x, y) {
            x %= this.#width;
            y %= this.#height;
            return this.#arr[x + y * this.#width];
        }

        getTileSize() {
            return this.#size;
        }

        draw() {
            for (let y = 0; y < this.#height; y++) {
                for (let x = 0; x < this.#width; x++) {
                    if (this.get(x, y) > 0) {
                        fill(0);
                        rectMode(CORNER);
                        rect(x * this.#size, y * this.#size, this.#size, this.#size);
                    }
                }
            }
        }
    }

    class AABB {
        center = createVector(0, 0);
        extents = createVector(0, 0);

        constructor(center, extents) {
            this.center = center;
            this.extents = extents;
        }

        getMin() {
            return p5.Vector.sub(this.center, this.extents);
        }

        getMax() {
            return p5.Vector.add(this.center, this.extents);
        }

        get min() {
            return this.getMin();
        }

        get max() {
            return this.getMax();
        }

        getSize() {
            return p5.Vector.mult(this.extents, 2);
        }

        overlaps(aabb) {
            return aabb.center.x - aabb.extents.x < this.center.x + this.extents.x &&
                aabb.center.x + aabb.extents.x > this.center.x - this.extents.x &&
                aabb.center.y - aabb.extents.y < this.center.y + this.extents.y &&
                aabb.center.y + aabb.extents.y > this.center.y - this.extents.y;
        }

        minkowskiDifference(aabb) {
            const topLeft = p5.Vector.sub(this.getMin(), aabb.getMax());
            const size = p5.Vector.add(this.getSize(), aabb.getSize());
            return new AABB(
                p5.Vector.add(topLeft, p5.Vector.div(size, 2)),
                p5.Vector.div(size, 2)
            );
        }

        closestMinkowskiPoint(point) {
            const min = this.getMin();
            const max = this.getMax();

            let minDist = Math.abs(point.x - min.x);
            let boundsPt = createVector(min.x, point.y);

            if (Math.abs(max.x - point.x) < minDist) {
                minDist = Math.abs(max.x - point.x);
                boundsPt = createVector(max.x, point.y);
            }

            if (Math.abs(max.y - point.y) < minDist) {
                minDist = Math.abs(max.y - point.y);
                boundsPt = createVector(point.x, max.y);
            }

            if (Math.abs(min.y - point.y) < minDist) {
                boundsPt = createVector(point.x, min.y);
            }

            return boundsPt;
        }

        draw(r, g, b) {
            fill(...arguments);
            rectMode(CENTER);
            rect(this.center.x, this.center.y, this.extents.x * 2, this.extents.y * 2);
        }
    }

    class Player extends AABB {

        #vel = createVector(0, 0);
        #jumping = false;

        update() {
            this.control();
            this.move();
            this.tileCollision();
            this.wallCollision();
        }

        control() {
            this.#vel.y += .8;

            if (keyIsDown(65)) {
                if (keyIsDown(65) && !keyIsDown(68))
                    player.walk(-speed)
            } else if (keyIsDown(68)) {
                if (!keyIsDown(65) && keyIsDown(68))
                    player.walk(speed)
            }

            if (keyIsDown(32)) {
                player.jump();
            }
        }

        move() {
            this.center.add(this.#vel);
            this.#vel.x = 0;
        }

        tileCollision() {
            let proxy = 1;
            let tileX = (this.extents.x * 2 / tileMap.getTileSize() | 0) + proxy;
            let tileY = (this.extents.y * 2 / tileMap.getTileSize() | 0) + proxy;

            for (let y = -proxy; y < tileY; y++) {
                for (let x = -proxy; x < tileX; x++) {
                    let xx = this.center.x / tileMap.getTileSize() | 0;
                    let yy = this.center.y / tileMap.getTileSize() | 0;
                    xx += x;
                    yy += y;

                    stroke(255);

                    if (tileMap.get(xx, yy) === 0) {
                        rectMode(CORNER);
                        fill(0, 0);
                        rect(xx * tileMap.getTileSize(), yy * tileMap.getTileSize(), tileMap.getTileSize(), tileMap.getTileSize());
                        noStroke();
                        continue;
                    }

                    let aabb = new AABB(
                        createVector(
                            xx * tileMap.getTileSize() + tileMap.getTileSize() / 2,
                            yy * tileMap.getTileSize() + tileMap.getTileSize() / 2),
                        createVector(
                            tileMap.getTileSize() / 2,
                            tileMap.getTileSize() / 2,
                        ));

                    let md = aabb.minkowskiDifference(this);
                    if (md.min.x <= 0 &&
                        md.max.x >= 0 &&
                        md.min.y <= 0 &&
                        md.max.y >= 0) {

                        let penVec = md.closestMinkowskiPoint(createVector(0, 0));
                        this.center.add(penVec);
                        stroke(255, 0, 0);

                        const deltaVec = p5.Vector.sub(this.center, aabb.center);
                        if (deltaVec.y * deltaVec.y > deltaVec.x * deltaVec.x) {
                            if (deltaVec.y > 0) {
                                this.getVel().y *= -.5; // Top collision
                            } else {
                                this.getVel().y = 0; // Bottom collision
                                this.setOnGround(true);
                            }
                        } else {
                            if (deltaVec.x > 0) {
                                this.getVel().x = 0; // Left collision
                            } else {
                                this.getVel().x = 0; // Right collision
                            }
                        }
                    }

                    fill(0, 0);
                    rectMode(CORNER);
                    rect(xx * tileMap.getTileSize(), yy * tileMap.getTileSize(), tileMap.getTileSize(), tileMap.getTileSize());
                    noStroke();
                }
            }
        }

        wallCollision() {

            if (this.center.x + this.extents.x > width) {
                this.center.x = width - this.extents.x;
            }
            if (this.center.x - this.extents.x < 0) {
                this.center.x = this.extents.x;
            }

            if (this.center.y + this.extents.y > height) {
                this.center.y = height - this.extents.y;
                this.#vel.y = 0;
                this.#jumping = false;
            }
        }

        walk(x) {
            this.#vel.x = x;
        }

        jump() {
            if (!this.#jumping) {
                this.#vel.y = -10;
                this.#jumping = true;
            }
        }

        setOnGround(value) {
            this.#jumping = !value;
        }

        getVel() {
            return this.#vel;
        }
    }

    let tileMap;
    let player;
    let obstacle;

    let speed;

    function setup() {
        createCanvas(320, 320);
        tileMap = new TileMap();
        player = new Player(createVector(32, 32), createVector(16, 16));
        obstacle = new AABB(createVector(width / 2, height - 12), createVector(12, 12));

        speed = 2;
    }

    function draw() {
        background(150);
        smooth();
        tileMap.draw();


        player.update();
        player.draw(0, 255, 0);
    }
</script>
</body>
</html>