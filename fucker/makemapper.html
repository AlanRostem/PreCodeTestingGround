<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MakeMapper</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<script>
    class IntervalTree {
        static #Interval = class Interval {
            constructor(low, high) {
                this.low = low;
                this.high = high;
            }
        };

        static #Node = class Node {
            constructor(left, right, value, max, interval) {
                this.left = left;
                this.right = right;
                this.value = value;
                this.interval = interval;
                this.max = max;
            }
        };

        static #checkOverlap = (i0, i1) => {
            return i0.low <= i1.high && i1.low <= i0.high;
        };

        #root = null;

        #newNode = (_interval, _value) => {
            return new this.constructor.#Node(null, null, _value, _interval.high, _interval);
        };

        #insertUtil = (_node, _interval, _value) => {
            if (_node == null) {
                return this.#newNode(_interval, _value);
            }

            let low = this.#root.interval.low;

            if (_interval.low < low) {
                this.#root.left = this.#insertUtil(this.#root.left, _interval, _value);
            } else {
                this.#root.right = this.#insertUtil(this.#root.right, _interval, _value);
            }

            if (this.#root.max < _interval.high) {
                this.#root.max = _interval.high;
            }

            return _node;
        };

        #overlapSearch = (_node, _interval) => {
            if (_node === null) return null;
            if (this.constructor.#checkOverlap(_node.interval, _interval)) {
                return _node.value;
            }

            if (_node.left !== null && _node.left.max >= _interval.low) {
                return this.#overlapSearch(_node.left, _interval);
            }

            return this.#overlapSearch(_node.right, _interval);
        };

        insert(low, high, value) {
            this.#root = this.#insertUtil(this.#root,
                new this.constructor.#Interval(low, high), value);
        }

        get(pos) {
            return this.#overlapSearch(this.#root, new this.constructor.#Interval(pos, pos));
        }
    }

    class Tile {
        static SIZE = 16;
        x = 0;
        y = 0;
        id = -1;

        constructor(x, y, id = -1) {
            this.x = x;
            this.y = y;
            this.id = id;
        }

        toVec() {
            return createVector(
                this.x * Tile.SIZE,
                this.y * Tile.SIZE,
            );
        }
    }


    class TileMap {
        static SIZE = 16;
        width = 0;
        height = 0;
        array = [];

        constructor(width = 20, height = 20, array = new Array(width * height).fill(0, 1, width * height)) {
            this.width = width;
            this.height = height;
            this.array = array;
        }

        getTileId(x, y) {
            return this.array[x + y * this.width];
        }

        draw() {
            for (let x = 0; x < this.width; x++)
                for (let y = 0; y < this.height; y++) {
                    let id = this.getTileId(x, y);
                    let pos = new Tile(x, y).toVec();
                    if (id > 0) {
                        id--;
                        let w = img.width / TileMap.SIZE | 0;
                        image(img, pos.x, pos.y,
                            TileMap.SIZE, TileMap.SIZE,

                            id % w * TileMap.SIZE, (id / w | 0) * TileMap.SIZE,
                            TileMap.SIZE, TileMap.SIZE);
                    } else {
                        stroke(0);
                        rect(pos.x, pos.y, TileMap.SIZE, TileMap.SIZE);
                    }
                    //stroke(255);
                    //text(id, pos.x + TileMap.SIZE / 2 - 3, pos.y + TileMap.SIZE / 2 + 3)
                }
        }

        setTile(x, y, id) {
            if (x >= 0 && x < this.width && y >= 0 && y < this.height)
                this.array[x + y * this.width] = id;
        }
    }

    class TilePathFormat {
        static TYPE_OFFSET = 3;

        constructor() {
            this.cases = {};
            this.createCase(5, [
                1, 2, 3,
                4, 5, 6,
                7, 8, 9
            ]);
        }

        getTileType(tile) {
            const TILES_PER_ROW = img.width / Tile.SIZE | 0;
            return ((tile - 1) % TILES_PER_ROW / TilePathFormat.TYPE_OFFSET | 0) + 1;
        }

        checkTileType(id0, id1) {
            if (id0 === 0 || id1 === 0) return false;
            return this.getTileType(id0) === this.getTileType(id1);
        }

        getTileByOffsetAndType(caseIndex, tile) {
            const TILES_PER_ROW = img.width / Tile.SIZE | 0;
            const x = caseIndex % TilePathFormat.TYPE_OFFSET;
            const y = caseIndex / TilePathFormat.TYPE_OFFSET | 0;
            return x + 1 + TILES_PER_ROW * y + (this.getTileType(tile) - 1) * TilePathFormat.TYPE_OFFSET;
        }

        createCase(id, _case) {
            let str = "";
            for (let i of _case) {
                str += i;
            }
            this.cases[str] = id;
        }

        getCaseId(_case) {
            let str = "";
            for (let i of _case) {
                str += i;
            }
            return this.cases[str];
        }

        paintTile(px, py, id) {
            makeMapper.tileMap.setTile(px, py, id);
            let _case = [
                1, 2, 3,
                4, 5, 6,
                7, 8, 9
            ];
            for (let x = 0; x < 3; x++)
                for (let y = 0; y < 3; y++) {
                    let xx = px + x - 1;
                    let yy = py + y - 1;
                    let tile = this.getTileByOffsetAndType(_case[x + 3 * y], id);
                    makeMapper.tileMap.setTile(xx, yy, tile);
                }
        }
    }

    class MakeMapper {
        constructor() {
            this.formatRanges = new IntervalTree();
            this.formatRanges.insert(0, 0, new TilePathFormat());
            this.formatRanges.insert(1, 54, new TilePathFormat());

            this.tileMap = new TileMap();
        }

        paintTile(mx, my) {
            let px = mx / TileMap.SIZE | 0;
            let py = my / TileMap.SIZE | 0;
            let w = img.width / TileMap.SIZE | 0;
            if ((id / w | 0) < ((img.height * img.width) / TileMap.SIZE | 0))
                makeMapper.getFormat(id).paintTile(px, py, id);

                /*for (let x = -1; x < 2; x++) {
                    for (let y = -1; y < 2; y++) {
                        let xx = px + x;
                        let yy = py + y;
                    }
                }*/
        }

        getFormat(tile) {
            let format = this.formatRanges.get(tile);
            if (format)
                 return format;
            return this.formatRanges.get(0);
        }

        draw() {
            this.tileMap.draw();
        }
    }

    let makeMapper;
    let img;
    let id = 1;

    function preload() {
        img = loadImage("tile-set-test.png");
    }

    function mouseDragged() {
        makeMapper.paintTile(mouseX, mouseY);
    }

    mousePressed = mouseDragged;

    function mouseWheel(event) {
        if (id >= 0) {
            id += Math.sign(event.delta);
            if (id < 0) id = 0;
            console.log(id);
        }
    }

    function setup() {
        createCanvas(320, 320);
        makeMapper = new MakeMapper();
    }

    function draw() {
        makeMapper.draw();
    }
</script>
</body>
</html>