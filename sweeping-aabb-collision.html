<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Swept AABB Collision Detection</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
</head>
<body>
<script>
    class AABB {
        constructor(center, extents) {
            this.center = center;
            this.extents = extents;
            this.color = color(random(100), random(100), random(100))
        }

        overlaps(aabb) {
            return (Math.abs(this.center.x - aabb.center.x) * 2 < (this.extents.x + aabb.extents.x) * 2) &&
                (Math.abs(this.center.y - aabb.center.y) * 2 < (this.extents.y + aabb.extents.y) * 2);
        }

        constrainPositionToScreen() {
            if (this.top < 0) {
                this.top = 0;
            }

            if (this.bottom > height) {
                this.bottom = height;
            }

            if (this.left < 0) {
                this.left = 0;
            }

            if (this.right > width) {
                this.right = width;
            }
        }

        get top() {
            return this.center.y - this.extents.y;
        }

        set top(y) {
            this.center.y = y + this.extents.y;
        }

        get bottom() {
            return this.center.y + this.extents.y;
        }

        set bottom(y) {
            this.center.y = y - this.extents.y;
        }

        get left() {
            return this.center.x - this.extents.x;
        }

        set left(x) {
            this.center.x = x + this.extents.x;
        }

        get right() {
            return this.center.x + this.extents.x;
        }

        set right(x) {
            this.center.x = x - this.extents.x;
        }

        update() {
            this.constrainPositionToScreen();
        }

        draw() {
            fill(this.color);
            rectMode(CENTER);
            stroke(255);
            rect(this.center.x, this.center.y, this.extents.x * 2, this.extents.y * 2);
        }
    }

    class MovingAABB extends AABB {
        constructor(center, extents) {
            super(center, extents);
            let tall = 50;
            this.vel = createVector(random(-tall, tall), random(-tall, tall));
            this.acc = createVector(0, 0);
        }

        updateMovement() {
            this.vel.add(p5.Vector.mult(this.acc, deltaTime / 1000));
            // this.center.add(p5.Vector.mult(this.vel, deltaTime / 1000));
        }

        update() {
            this.updateMovement();
            super.update();
        }
    }

    class Sweep {
        constructor(collisionTime = 1, normal = createVector(0, 0)) {
            this.collisionTime = collisionTime;
            this.normal = normal;
        }
    }

    class CollisionStack {
        static #MAX_LENGTH = 5;
        #array = [];

        constructor(...args) {
            this.#array = args;
        }

        push(sweep) {
            if (!this.isFull())
                this.#array.push(sweep);
        }

        pop() {
            return this.#array.shift();
        }

        isFull() {
            return this.#array.length === CollisionStack.#MAX_LENGTH;
        }

        isEmpty() {
            return this.#array.length === 0;
        }
    }

    class CollidingAABB extends MovingAABB {
        collisionStack = [];

        update() {
            this.boundary = this.getCollisionBoundary();
            this.checkCollision();
            this.updateMovement();

            this.constrainPositionToScreen();
        }

        getCollisionBoundary() {
            let collisionBoundary = new AABB(this.center.copy(), this.extents.copy());
            let vel = p5.Vector.mult(this.vel, deltaTime / 1000);
            if (vel.x > 0) {
                collisionBoundary.extents.x = this.extents.x + vel.x;
                collisionBoundary.left = this.left;
            } else {
                collisionBoundary.extents.x = this.extents.x - vel.x;
                collisionBoundary.right = this.right;
            }

            if (vel.y > 0) {
                collisionBoundary.extents.y = this.extents.y + vel.y;
                collisionBoundary.top = this.top;
            } else {
                collisionBoundary.extents.y = this.extents.y - vel.y;
                collisionBoundary.bottom = this.bottom;
            }
            return collisionBoundary;
        }

        draw() {
            super.draw();
            noFill();
            stroke(255, 255, 0);
            strokeWeight(2);
            let collisionBoundary = this.getCollisionBoundary();
            rect(
                collisionBoundary.center.x,
                collisionBoundary.center.y,
                collisionBoundary.extents.x * 2,
                collisionBoundary.extents.y * 2,
            )
        }

        checkCollision(movement = this.vel, remainingTime = 1, collisionStack = entities) {
            /*let toIterate = this.collisionStack;
            if (this.collisionStack.length === 0) toIterate = entities;
            else this.collisionStack = [];*/
            let nearest;
            let stack = [];

            for (let entity of collisionStack) {
                if (entity !== this) {
                    if (this.getCollisionBoundary().overlaps(entity)) {
                        let sweep = this.getSweepObject(entity, movement);
                        stack.push(entity);
                        if (nearest) {
                            if (sweep.collisionTime < nearest.collisionTime) {
                                nearest = sweep;
                            }
                        } else {
                            nearest = sweep;
                        }
                    }
                }
            }

            if (nearest) {
                this.center.x += movement.x * nearest.collisionTime * deltaTime / 1000;
                this.center.y += movement.y * nearest.collisionTime * deltaTime / 1000;

                let time = remainingTime - nearest.collisionTime;
                let dotProduct = p5.Vector.dot(movement, nearest.normal) * time;
                nearest.normal.mult(dotProduct);

                if (time > 0)
                    this.checkCollision(nearest.normal, time, stack);

                stroke(255, 0, 0);
                line(
                    this.center.x,
                    this.center.y,
                    this.center.x + nearest.normal.x / dotProduct * this.extents.x,
                    this.center.y + nearest.normal.y / dotProduct * this.extents.y);

                //this.center.x += nearest.normal.x * dotProduct * deltaTime / 1000;
                //this.center.y += nearest.normal.y * dotProduct * deltaTime / 1000;
            } else {
                this.center.add(p5.Vector.mult(movement, deltaTime / 1000))
            }
        }

        getSweepObject(aabb, movement) {
            let deltaEntry = createVector(0, 0);
            let deltaExit = createVector(0, 0);

            let velocity = p5.Vector.mult(movement, deltaTime / 1000);

            if (velocity.x > 0) {
                deltaEntry.x = aabb.left - this.right;
                deltaExit.x = aabb.right - this.left;
            } else {
                deltaEntry.x = aabb.right - this.left;
                deltaExit.x = aabb.left - this.right;
            }

            if (velocity.y > 0) {
                deltaEntry.y = aabb.top - this.bottom;
                deltaExit.y = aabb.bottom - this.top;
            } else {
                deltaEntry.y = aabb.bottom - this.top;
                deltaExit.y = aabb.top - this.bottom;
            }

            let entryTime = createVector(0, 0);
            let exitTime = createVector(0, 0);

            if (velocity.x === 0) {
                entryTime.x = -Infinity;
                exitTime.x = Infinity;
            } else {
                entryTime.x = deltaEntry.x / velocity.x;
                exitTime.x = deltaExit.x / velocity.x;
            }

            if (velocity.y === 0) {
                entryTime.y = -Infinity;
                exitTime.y = Infinity;
            } else {
                entryTime.y = deltaEntry.y / velocity.y;
                exitTime.y = deltaExit.y / velocity.y;
            }

            if (entryTime.y > 1) entryTime.y = -Infinity;
            if (entryTime.x > 1) entryTime.x = -Infinity;

            let maxEntryTime = Math.max(entryTime.x, entryTime.y);
            let minExitTime = Math.min(exitTime.x, exitTime.y);

            let resultTime = 1;
            let normal = createVector();

            if (!(maxEntryTime > minExitTime ||
                (entryTime.x < 0 && entryTime.y < 0)
                || (entryTime.x < 0 && (this.right < aabb.left || this.left > aabb.right))
                || (entryTime.y < 0 && (this.bottom < aabb.top || this.top > aabb.bottom))
            )) {
                resultTime = maxEntryTime;
                if (Math.abs(deltaEntry.x) > Math.abs(deltaEntry.y)) { // <- HAHAAHAH d låg her xDDDDDD de glømte abs djhdsjkdhjk
                    if (deltaEntry.x < 0) {
                        normal = createVector(1, 0);
                    } else {
                        normal = createVector(-1, 0);
                    }
                } else {
                    if (deltaEntry.y < 0) {
                        normal = createVector(0, 1);
                    } else {
                        normal = createVector(0, -1);
                    }
                }
            }

            return new Sweep(resultTime, normal);
        }
    }

    class Player extends CollidingAABB {
        acc = createVector();
        speed = 250;

        update() {
            if (keyIsDown(65)) this.vel.x = -this.speed;
            if (keyIsDown(68)) this.vel.x = this.speed;
            if (keyIsDown(87)) this.vel.y = -this.speed;
            if (keyIsDown(83)) this.vel.y = this.speed;

            this.checkCollision(this.vel);
            this.updateMovement();
            this.vel = createVector();
            this.constrainPositionToScreen();
        }
    }

    let entities;
    let player;

    addEventListener("contextmenu", e => e.preventDefault())

    function mousePressed() {
        if (mouseButton !== "right" && mouseButton !== "center")
            entities.push(
                new CollidingAABB(
                    createVector(mouseX, mouseY),
                    createVector(random(32, 16), random(32, 16)),
                ));
        else if (mouseButton === "right") {
            for (let e of entities) {
                let aabb = new AABB(createVector(mouseX, mouseY), createVector(0, 0));
                if (aabb.overlaps(e)) console.log(e);
            }
            return true;
        }
    }

    function setup() {
        createCanvas(640, 640);
        document.body.style.margin = 0;
        player = new Player(createVector(320, 320), createVector(16, 16));
        entities = [player];
    }

    function draw() {
        background(0);
        frameRate(144);
        for (let entity of entities) {
            entity.draw();
        }
        for (let entity of entities) {
            entity.update();
        }
    }
</script>
</body>
</html>
